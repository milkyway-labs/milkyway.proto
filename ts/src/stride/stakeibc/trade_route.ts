// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: stride/stakeibc/trade_route.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { ICAAccount } from "./ica_account";
import Long = require("long");

export const protobufPackage = "stride.stakeibc";

/** Stores pool information needed to execute the swap along a trade route */
export interface TradeConfig {
  /** Currently Osmosis is the only trade chain so this is an osmosis pool id */
  poolId: number;
  /**
   * Spot price in the pool to convert the reward denom to the host denom
   * output_tokens = swap_price * input tokens
   * This value may be slightly stale as it is updated by an ICQ
   */
  swapPrice: string;
  /** unix time in seconds that the price was last updated */
  priceUpdateTimestamp: number;
  /**
   * Threshold defining the percentage of tokens that could be lost in the trade
   * This captures both the loss from slippage and from a stale price on stride
   * 0.05 means the output from the trade can be no less than a 5% deviation
   * from the current value
   */
  maxAllowedSwapLossRate: string;
  /**
   * min and max set boundaries of reward denom on trade chain we will swap
   * min also decides when reward token transfers are worth it (transfer fees)
   */
  minSwapAmount: string;
  maxSwapAmount: string;
}

/**
 * TradeRoute represents a round trip including info on transfer and how to do
 * the swap. It makes the assumption that the reward token is always foreign to
 * the host so therefore the first two hops are to unwind the ibc denom enroute
 * to the trade chain and the last hop is the return so funds start/end in the
 * withdrawl ICA on hostZone
 * The structure is key'd on reward denom and host denom in their native forms
 * (i.e. reward_denom_on_reward_zone and host_denom_on_host_zone)
 */
export interface TradeRoute {
  /** ibc denom for the reward on the host zone */
  rewardDenomOnHostZone: string;
  /** should be the native denom for the reward chain */
  rewardDenomOnRewardZone: string;
  /** ibc denom of the reward on the trade chain, input to the swap */
  rewardDenomOnTradeZone: string;
  /** ibc of the host denom on the trade chain, output from the swap */
  hostDenomOnTradeZone: string;
  /** should be the same as the native host denom on the host chain */
  hostDenomOnHostZone: string;
  /**
   * ICAAccount on the host zone with the reward tokens
   * This is the same as the host zone withdrawal ICA account
   */
  hostAccount:
    | ICAAccount
    | undefined;
  /**
   * ICAAccount on the reward zone that is acts as the intermediate
   * receiver of the transfer from host zone to trade zone
   */
  rewardAccount:
    | ICAAccount
    | undefined;
  /**
   * ICAAccount responsible for executing the swap of reward
   * tokens for host tokens
   */
  tradeAccount:
    | ICAAccount
    | undefined;
  /**
   * Channel responsible for the transfer of reward tokens from the host
   * zone to the reward zone. This is the channel ID on the host zone side
   */
  hostToRewardChannelId: string;
  /**
   * Channel responsible for the transfer of reward tokens from the reward
   * zone to the trade zone. This is the channel ID on the reward zone side
   */
  rewardToTradeChannelId: string;
  /**
   * Channel responsible for the transfer of host tokens from the trade
   * zone, back to the host zone. This is the channel ID on the trade zone side
   */
  tradeToHostChannelId: string;
  /**
   * specifies the configuration needed to execute the swap
   * such as pool_id, slippage, min trade amount, etc.
   */
  tradeConfig: TradeConfig | undefined;
}

function createBaseTradeConfig(): TradeConfig {
  return {
    poolId: 0,
    swapPrice: "",
    priceUpdateTimestamp: 0,
    maxAllowedSwapLossRate: "",
    minSwapAmount: "",
    maxSwapAmount: "",
  };
}

export const TradeConfig = {
  encode(message: TradeConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.poolId !== 0) {
      writer.uint32(8).uint64(message.poolId);
    }
    if (message.swapPrice !== "") {
      writer.uint32(18).string(message.swapPrice);
    }
    if (message.priceUpdateTimestamp !== 0) {
      writer.uint32(24).uint64(message.priceUpdateTimestamp);
    }
    if (message.maxAllowedSwapLossRate !== "") {
      writer.uint32(34).string(message.maxAllowedSwapLossRate);
    }
    if (message.minSwapAmount !== "") {
      writer.uint32(42).string(message.minSwapAmount);
    }
    if (message.maxSwapAmount !== "") {
      writer.uint32(50).string(message.maxSwapAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradeConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.poolId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.swapPrice = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.priceUpdateTimestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maxAllowedSwapLossRate = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.minSwapAmount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.maxSwapAmount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TradeConfig {
    return {
      poolId: isSet(object.poolId) ? gt.Number(object.poolId) : 0,
      swapPrice: isSet(object.swapPrice) ? gt.String(object.swapPrice) : "",
      priceUpdateTimestamp: isSet(object.priceUpdateTimestamp) ? gt.Number(object.priceUpdateTimestamp) : 0,
      maxAllowedSwapLossRate: isSet(object.maxAllowedSwapLossRate) ? gt.String(object.maxAllowedSwapLossRate) : "",
      minSwapAmount: isSet(object.minSwapAmount) ? gt.String(object.minSwapAmount) : "",
      maxSwapAmount: isSet(object.maxSwapAmount) ? gt.String(object.maxSwapAmount) : "",
    };
  },

  toJSON(message: TradeConfig): unknown {
    const obj: any = {};
    if (message.poolId !== 0) {
      obj.poolId = Math.round(message.poolId);
    }
    if (message.swapPrice !== "") {
      obj.swapPrice = message.swapPrice;
    }
    if (message.priceUpdateTimestamp !== 0) {
      obj.priceUpdateTimestamp = Math.round(message.priceUpdateTimestamp);
    }
    if (message.maxAllowedSwapLossRate !== "") {
      obj.maxAllowedSwapLossRate = message.maxAllowedSwapLossRate;
    }
    if (message.minSwapAmount !== "") {
      obj.minSwapAmount = message.minSwapAmount;
    }
    if (message.maxSwapAmount !== "") {
      obj.maxSwapAmount = message.maxSwapAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<TradeConfig>): TradeConfig {
    return TradeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TradeConfig>): TradeConfig {
    const message = createBaseTradeConfig();
    message.poolId = object.poolId ?? 0;
    message.swapPrice = object.swapPrice ?? "";
    message.priceUpdateTimestamp = object.priceUpdateTimestamp ?? 0;
    message.maxAllowedSwapLossRate = object.maxAllowedSwapLossRate ?? "";
    message.minSwapAmount = object.minSwapAmount ?? "";
    message.maxSwapAmount = object.maxSwapAmount ?? "";
    return message;
  },
};

function createBaseTradeRoute(): TradeRoute {
  return {
    rewardDenomOnHostZone: "",
    rewardDenomOnRewardZone: "",
    rewardDenomOnTradeZone: "",
    hostDenomOnTradeZone: "",
    hostDenomOnHostZone: "",
    hostAccount: undefined,
    rewardAccount: undefined,
    tradeAccount: undefined,
    hostToRewardChannelId: "",
    rewardToTradeChannelId: "",
    tradeToHostChannelId: "",
    tradeConfig: undefined,
  };
}

export const TradeRoute = {
  encode(message: TradeRoute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rewardDenomOnHostZone !== "") {
      writer.uint32(10).string(message.rewardDenomOnHostZone);
    }
    if (message.rewardDenomOnRewardZone !== "") {
      writer.uint32(18).string(message.rewardDenomOnRewardZone);
    }
    if (message.rewardDenomOnTradeZone !== "") {
      writer.uint32(26).string(message.rewardDenomOnTradeZone);
    }
    if (message.hostDenomOnTradeZone !== "") {
      writer.uint32(34).string(message.hostDenomOnTradeZone);
    }
    if (message.hostDenomOnHostZone !== "") {
      writer.uint32(42).string(message.hostDenomOnHostZone);
    }
    if (message.hostAccount !== undefined) {
      ICAAccount.encode(message.hostAccount, writer.uint32(50).fork()).ldelim();
    }
    if (message.rewardAccount !== undefined) {
      ICAAccount.encode(message.rewardAccount, writer.uint32(58).fork()).ldelim();
    }
    if (message.tradeAccount !== undefined) {
      ICAAccount.encode(message.tradeAccount, writer.uint32(66).fork()).ldelim();
    }
    if (message.hostToRewardChannelId !== "") {
      writer.uint32(74).string(message.hostToRewardChannelId);
    }
    if (message.rewardToTradeChannelId !== "") {
      writer.uint32(82).string(message.rewardToTradeChannelId);
    }
    if (message.tradeToHostChannelId !== "") {
      writer.uint32(90).string(message.tradeToHostChannelId);
    }
    if (message.tradeConfig !== undefined) {
      TradeConfig.encode(message.tradeConfig, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradeRoute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rewardDenomOnHostZone = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rewardDenomOnRewardZone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rewardDenomOnTradeZone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hostDenomOnTradeZone = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hostDenomOnHostZone = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.hostAccount = ICAAccount.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.rewardAccount = ICAAccount.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tradeAccount = ICAAccount.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.hostToRewardChannelId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.rewardToTradeChannelId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.tradeToHostChannelId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.tradeConfig = TradeConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TradeRoute {
    return {
      rewardDenomOnHostZone: isSet(object.rewardDenomOnHostZone) ? gt.String(object.rewardDenomOnHostZone) : "",
      rewardDenomOnRewardZone: isSet(object.rewardDenomOnRewardZone) ? gt.String(object.rewardDenomOnRewardZone) : "",
      rewardDenomOnTradeZone: isSet(object.rewardDenomOnTradeZone) ? gt.String(object.rewardDenomOnTradeZone) : "",
      hostDenomOnTradeZone: isSet(object.hostDenomOnTradeZone) ? gt.String(object.hostDenomOnTradeZone) : "",
      hostDenomOnHostZone: isSet(object.hostDenomOnHostZone) ? gt.String(object.hostDenomOnHostZone) : "",
      hostAccount: isSet(object.hostAccount) ? ICAAccount.fromJSON(object.hostAccount) : undefined,
      rewardAccount: isSet(object.rewardAccount) ? ICAAccount.fromJSON(object.rewardAccount) : undefined,
      tradeAccount: isSet(object.tradeAccount) ? ICAAccount.fromJSON(object.tradeAccount) : undefined,
      hostToRewardChannelId: isSet(object.hostToRewardChannelId) ? gt.String(object.hostToRewardChannelId) : "",
      rewardToTradeChannelId: isSet(object.rewardToTradeChannelId) ? gt.String(object.rewardToTradeChannelId) : "",
      tradeToHostChannelId: isSet(object.tradeToHostChannelId) ? gt.String(object.tradeToHostChannelId) : "",
      tradeConfig: isSet(object.tradeConfig) ? TradeConfig.fromJSON(object.tradeConfig) : undefined,
    };
  },

  toJSON(message: TradeRoute): unknown {
    const obj: any = {};
    if (message.rewardDenomOnHostZone !== "") {
      obj.rewardDenomOnHostZone = message.rewardDenomOnHostZone;
    }
    if (message.rewardDenomOnRewardZone !== "") {
      obj.rewardDenomOnRewardZone = message.rewardDenomOnRewardZone;
    }
    if (message.rewardDenomOnTradeZone !== "") {
      obj.rewardDenomOnTradeZone = message.rewardDenomOnTradeZone;
    }
    if (message.hostDenomOnTradeZone !== "") {
      obj.hostDenomOnTradeZone = message.hostDenomOnTradeZone;
    }
    if (message.hostDenomOnHostZone !== "") {
      obj.hostDenomOnHostZone = message.hostDenomOnHostZone;
    }
    if (message.hostAccount !== undefined) {
      obj.hostAccount = ICAAccount.toJSON(message.hostAccount);
    }
    if (message.rewardAccount !== undefined) {
      obj.rewardAccount = ICAAccount.toJSON(message.rewardAccount);
    }
    if (message.tradeAccount !== undefined) {
      obj.tradeAccount = ICAAccount.toJSON(message.tradeAccount);
    }
    if (message.hostToRewardChannelId !== "") {
      obj.hostToRewardChannelId = message.hostToRewardChannelId;
    }
    if (message.rewardToTradeChannelId !== "") {
      obj.rewardToTradeChannelId = message.rewardToTradeChannelId;
    }
    if (message.tradeToHostChannelId !== "") {
      obj.tradeToHostChannelId = message.tradeToHostChannelId;
    }
    if (message.tradeConfig !== undefined) {
      obj.tradeConfig = TradeConfig.toJSON(message.tradeConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<TradeRoute>): TradeRoute {
    return TradeRoute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TradeRoute>): TradeRoute {
    const message = createBaseTradeRoute();
    message.rewardDenomOnHostZone = object.rewardDenomOnHostZone ?? "";
    message.rewardDenomOnRewardZone = object.rewardDenomOnRewardZone ?? "";
    message.rewardDenomOnTradeZone = object.rewardDenomOnTradeZone ?? "";
    message.hostDenomOnTradeZone = object.hostDenomOnTradeZone ?? "";
    message.hostDenomOnHostZone = object.hostDenomOnHostZone ?? "";
    message.hostAccount = (object.hostAccount !== undefined && object.hostAccount !== null)
      ? ICAAccount.fromPartial(object.hostAccount)
      : undefined;
    message.rewardAccount = (object.rewardAccount !== undefined && object.rewardAccount !== null)
      ? ICAAccount.fromPartial(object.rewardAccount)
      : undefined;
    message.tradeAccount = (object.tradeAccount !== undefined && object.tradeAccount !== null)
      ? ICAAccount.fromPartial(object.tradeAccount)
      : undefined;
    message.hostToRewardChannelId = object.hostToRewardChannelId ?? "";
    message.rewardToTradeChannelId = object.rewardToTradeChannelId ?? "";
    message.tradeToHostChannelId = object.tradeToHostChannelId ?? "";
    message.tradeConfig = (object.tradeConfig !== undefined && object.tradeConfig !== null)
      ? TradeConfig.fromPartial(object.tradeConfig)
      : undefined;
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(gt.Number.MAX_SAFE_INTEGER)) {
    throw new gt.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(gt.Number.MIN_SAFE_INTEGER)) {
    throw new gt.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
