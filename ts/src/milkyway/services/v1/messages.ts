// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: milkyway/services/v1/messages.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ServiceParams } from "./models";
import { Params } from "./params";

export const protobufPackage = "milkyway.services.v1";

/**
 * MsgCreateServiceResponse defines the message structure for the
 * CreateService gRPC service method. It allows an account to register a new
 * service that can be validated by operators. It requires a sender address
 * as well as the details of the service to be registered.
 */
export interface MsgCreateService {
  /** Sender is the address of the user registering the service */
  sender: string;
  /** Name is the name of the service */
  name: string;
  /** Description is the description of the service */
  description: string;
  /** Website is the website of the service */
  website: string;
  /** PictureURL is the URL of the service picture */
  pictureUrl: string;
}

/**
 * MsgCreateServiceResponse is the return value of MsgCreateService.
 * It returns the newly created service ID.
 */
export interface MsgCreateServiceResponse {
  /** NewServiceID is the ID of the newly registered service */
  newServiceId: number;
}

/**
 * MsgUpdateService defines the message structure for the UpdateService gRPC
 * service method. It allows the service admin to update the details of
 * an existing service.
 */
export interface MsgUpdateService {
  /** Sender is the address of the user updating the service */
  sender: string;
  /** ID represents the ID of the service to be updated */
  serviceId: number;
  /**
   * Name is the new name of the service.
   * If it shouldn't be changed, use [do-not-modify] instead.
   */
  name: string;
  /**
   * Description is the new description of the service.
   * If it shouldn't be changed, use [do-not-modify] instead.
   */
  description: string;
  /**
   * Website is the new website of the service.
   * If it shouldn't be changed, use [do-not-modify] instead.
   */
  website: string;
  /**
   * PictureURL is the new URL of the service picture.
   * If it shouldn't be changed, use [do-not-modify] instead.
   */
  pictureUrl: string;
}

/** MsgUpdateServiceResponse is the return value of MsgUpdateService. */
export interface MsgUpdateServiceResponse {
}

/** MsgActivateService defines the message structure for the ActivateService gRPC */
export interface MsgActivateService {
  /** Sender is the address of the user that wants to activate the service */
  sender: string;
  /** ServiceID represents the ID of the service to be activated */
  serviceId: number;
}

/** MsgActivateServiceResponse is the return value of MsgActivateService. */
export interface MsgActivateServiceResponse {
}

/**
 * MsgDeactivateService defines the message structure for the DeactivateService
 * gRPC service method. It allows the service admin to deactivate an existing
 * service.
 */
export interface MsgDeactivateService {
  /** Sender is the address of the user that wants to deactivate the service */
  sender: string;
  /** ServiceID represents the ID of the service to be deactivated */
  serviceId: number;
}

/** MsgDeactivateServiceResponse is the return value of MsgDeactivateService. */
export interface MsgDeactivateServiceResponse {
}

/**
 * MsgDeleteService defines the message structure for the DeleteService
 * gRPC service method. It allows the service admin to delete a previously
 * deactivated service
 */
export interface MsgDeleteService {
  /** Sender is the address of the user that wants to delete the service */
  sender: string;
  /** ServiceID represents the ID of the service to be deleted */
  serviceId: number;
}

/** MsgDeleteServiceResponse is the return value of MsgDeleteService. */
export interface MsgDeleteServiceResponse {
}

/**
 * MsgTransferServiceOwnership defines the message structure for the
 * TransferServiceOwnership gRPC service method. It allows a service admin to
 * transfer the ownership of the service to another account.
 */
export interface MsgTransferServiceOwnership {
  /** Sender is the address of the user transferring the ownership */
  sender: string;
  /** ServiceID represents the ID of the service to transfer ownership */
  serviceId: number;
  /** NewAdmin is the address of the new admin of the service */
  newAdmin: string;
}

/**
 * MsgTransferServiceOwnershipResponse is the return value of
 * MsgTransferServiceOwnership.
 */
export interface MsgTransferServiceOwnershipResponse {
}

/**
 * MsgSetServiceParams defines the message structure for the
 * SetServiceParams gRPC service method. It allows a service admin to
 * update the parameters of a service.
 */
export interface MsgSetServiceParams {
  /** Sender is the address of the user setting the parameters */
  sender: string;
  /** ServiceID is the ID of the service whose parameters are being set */
  serviceId: number;
  /** ServiceParams defines the new parameters of the service */
  serviceParams: ServiceParams | undefined;
}

/** MsgSetServiceParamsResponse is the return value of MsgSetServiceParams. */
export interface MsgSetServiceParamsResponse {
}

/**
 * MsgDeactivateService defines the message structure for the UpdateParams gRPC
 * service method. It allows the authority to update the module parameters.
 */
export interface MsgUpdateParams {
  /**
   * Authority is the address that controls the module (defaults to x/gov unless
   * overwritten).
   */
  authority: string;
  /**
   * Params define the parameters to update.
   *
   * NOTE: All parameters must be supplied.
   */
  params: Params | undefined;
}

/** MsgDeactivateServiceResponse is the return value of MsgUpdateParams. */
export interface MsgUpdateParamsResponse {
}

/**
 * MsgAccreditService defines the message structure for the AccreditService gRPC
 * service method. It allows the authority to accredit a service.
 */
export interface MsgAccreditService {
  /**
   * Authority is the address that controls the module (defaults to x/gov unless
   * overwritten).
   */
  authority: string;
  /** ServiceID represents the ID of the service to be accredited */
  serviceId: number;
}

/** MsgAccreditServiceResponse is the return value of MsgAccreditService. */
export interface MsgAccreditServiceResponse {
}

/**
 * MsgRevokeServiceAccreditation defines the message structure for the
 * RevokeServiceAccreditation gRPC service method. It allows the authority to
 * revoke a service's accreditation.
 */
export interface MsgRevokeServiceAccreditation {
  /**
   * Authority is the address that controls the module (defaults to x/gov unless
   * overwritten).
   */
  authority: string;
  /**
   * ServiceID represents the ID of the service to have its accreditation
   * revoked
   */
  serviceId: number;
}

/**
 * MsgRevokeServiceAccreditationResponse is the return value of
 * MsgRevokeServiceAccreditation.
 */
export interface MsgRevokeServiceAccreditationResponse {
}

function createBaseMsgCreateService(): MsgCreateService {
  return { sender: "", name: "", description: "", website: "", pictureUrl: "" };
}

export const MsgCreateService: MessageFns<MsgCreateService> = {
  encode(message: MsgCreateService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.website !== "") {
      writer.uint32(34).string(message.website);
    }
    if (message.pictureUrl !== "") {
      writer.uint32(42).string(message.pictureUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pictureUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateService {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      name: isSet(object.name) ? gt.String(object.name) : "",
      description: isSet(object.description) ? gt.String(object.description) : "",
      website: isSet(object.website) ? gt.String(object.website) : "",
      pictureUrl: isSet(object.pictureUrl) ? gt.String(object.pictureUrl) : "",
    };
  },

  toJSON(message: MsgCreateService): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.website !== "") {
      obj.website = message.website;
    }
    if (message.pictureUrl !== "") {
      obj.pictureUrl = message.pictureUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgCreateService>): MsgCreateService {
    return MsgCreateService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgCreateService>): MsgCreateService {
    const message = createBaseMsgCreateService();
    message.sender = object.sender ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.website = object.website ?? "";
    message.pictureUrl = object.pictureUrl ?? "";
    return message;
  },
};

function createBaseMsgCreateServiceResponse(): MsgCreateServiceResponse {
  return { newServiceId: 0 };
}

export const MsgCreateServiceResponse: MessageFns<MsgCreateServiceResponse> = {
  encode(message: MsgCreateServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newServiceId !== 0) {
      writer.uint32(8).uint32(message.newServiceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.newServiceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateServiceResponse {
    return { newServiceId: isSet(object.newServiceId) ? gt.Number(object.newServiceId) : 0 };
  },

  toJSON(message: MsgCreateServiceResponse): unknown {
    const obj: any = {};
    if (message.newServiceId !== 0) {
      obj.newServiceId = Math.round(message.newServiceId);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgCreateServiceResponse>): MsgCreateServiceResponse {
    return MsgCreateServiceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgCreateServiceResponse>): MsgCreateServiceResponse {
    const message = createBaseMsgCreateServiceResponse();
    message.newServiceId = object.newServiceId ?? 0;
    return message;
  },
};

function createBaseMsgUpdateService(): MsgUpdateService {
  return { sender: "", serviceId: 0, name: "", description: "", website: "", pictureUrl: "" };
}

export const MsgUpdateService: MessageFns<MsgUpdateService> = {
  encode(message: MsgUpdateService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.serviceId !== 0) {
      writer.uint32(16).uint32(message.serviceId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.website !== "") {
      writer.uint32(42).string(message.website);
    }
    if (message.pictureUrl !== "") {
      writer.uint32(50).string(message.pictureUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pictureUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateService {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      serviceId: isSet(object.serviceId) ? gt.Number(object.serviceId) : 0,
      name: isSet(object.name) ? gt.String(object.name) : "",
      description: isSet(object.description) ? gt.String(object.description) : "",
      website: isSet(object.website) ? gt.String(object.website) : "",
      pictureUrl: isSet(object.pictureUrl) ? gt.String(object.pictureUrl) : "",
    };
  },

  toJSON(message: MsgUpdateService): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.website !== "") {
      obj.website = message.website;
    }
    if (message.pictureUrl !== "") {
      obj.pictureUrl = message.pictureUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateService>): MsgUpdateService {
    return MsgUpdateService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateService>): MsgUpdateService {
    const message = createBaseMsgUpdateService();
    message.sender = object.sender ?? "";
    message.serviceId = object.serviceId ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.website = object.website ?? "";
    message.pictureUrl = object.pictureUrl ?? "";
    return message;
  },
};

function createBaseMsgUpdateServiceResponse(): MsgUpdateServiceResponse {
  return {};
}

export const MsgUpdateServiceResponse: MessageFns<MsgUpdateServiceResponse> = {
  encode(_: MsgUpdateServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateServiceResponse {
    return {};
  },

  toJSON(_: MsgUpdateServiceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateServiceResponse>): MsgUpdateServiceResponse {
    return MsgUpdateServiceResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateServiceResponse>): MsgUpdateServiceResponse {
    const message = createBaseMsgUpdateServiceResponse();
    return message;
  },
};

function createBaseMsgActivateService(): MsgActivateService {
  return { sender: "", serviceId: 0 };
}

export const MsgActivateService: MessageFns<MsgActivateService> = {
  encode(message: MsgActivateService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.serviceId !== 0) {
      writer.uint32(16).uint32(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgActivateService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgActivateService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgActivateService {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      serviceId: isSet(object.serviceId) ? gt.Number(object.serviceId) : 0,
    };
  },

  toJSON(message: MsgActivateService): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgActivateService>): MsgActivateService {
    return MsgActivateService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgActivateService>): MsgActivateService {
    const message = createBaseMsgActivateService();
    message.sender = object.sender ?? "";
    message.serviceId = object.serviceId ?? 0;
    return message;
  },
};

function createBaseMsgActivateServiceResponse(): MsgActivateServiceResponse {
  return {};
}

export const MsgActivateServiceResponse: MessageFns<MsgActivateServiceResponse> = {
  encode(_: MsgActivateServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgActivateServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgActivateServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgActivateServiceResponse {
    return {};
  },

  toJSON(_: MsgActivateServiceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgActivateServiceResponse>): MsgActivateServiceResponse {
    return MsgActivateServiceResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgActivateServiceResponse>): MsgActivateServiceResponse {
    const message = createBaseMsgActivateServiceResponse();
    return message;
  },
};

function createBaseMsgDeactivateService(): MsgDeactivateService {
  return { sender: "", serviceId: 0 };
}

export const MsgDeactivateService: MessageFns<MsgDeactivateService> = {
  encode(message: MsgDeactivateService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.serviceId !== 0) {
      writer.uint32(16).uint32(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeactivateService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeactivateService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeactivateService {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      serviceId: isSet(object.serviceId) ? gt.Number(object.serviceId) : 0,
    };
  },

  toJSON(message: MsgDeactivateService): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgDeactivateService>): MsgDeactivateService {
    return MsgDeactivateService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgDeactivateService>): MsgDeactivateService {
    const message = createBaseMsgDeactivateService();
    message.sender = object.sender ?? "";
    message.serviceId = object.serviceId ?? 0;
    return message;
  },
};

function createBaseMsgDeactivateServiceResponse(): MsgDeactivateServiceResponse {
  return {};
}

export const MsgDeactivateServiceResponse: MessageFns<MsgDeactivateServiceResponse> = {
  encode(_: MsgDeactivateServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeactivateServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeactivateServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeactivateServiceResponse {
    return {};
  },

  toJSON(_: MsgDeactivateServiceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgDeactivateServiceResponse>): MsgDeactivateServiceResponse {
    return MsgDeactivateServiceResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgDeactivateServiceResponse>): MsgDeactivateServiceResponse {
    const message = createBaseMsgDeactivateServiceResponse();
    return message;
  },
};

function createBaseMsgDeleteService(): MsgDeleteService {
  return { sender: "", serviceId: 0 };
}

export const MsgDeleteService: MessageFns<MsgDeleteService> = {
  encode(message: MsgDeleteService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.serviceId !== 0) {
      writer.uint32(16).uint32(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteService {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      serviceId: isSet(object.serviceId) ? gt.Number(object.serviceId) : 0,
    };
  },

  toJSON(message: MsgDeleteService): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgDeleteService>): MsgDeleteService {
    return MsgDeleteService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgDeleteService>): MsgDeleteService {
    const message = createBaseMsgDeleteService();
    message.sender = object.sender ?? "";
    message.serviceId = object.serviceId ?? 0;
    return message;
  },
};

function createBaseMsgDeleteServiceResponse(): MsgDeleteServiceResponse {
  return {};
}

export const MsgDeleteServiceResponse: MessageFns<MsgDeleteServiceResponse> = {
  encode(_: MsgDeleteServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteServiceResponse {
    return {};
  },

  toJSON(_: MsgDeleteServiceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgDeleteServiceResponse>): MsgDeleteServiceResponse {
    return MsgDeleteServiceResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgDeleteServiceResponse>): MsgDeleteServiceResponse {
    const message = createBaseMsgDeleteServiceResponse();
    return message;
  },
};

function createBaseMsgTransferServiceOwnership(): MsgTransferServiceOwnership {
  return { sender: "", serviceId: 0, newAdmin: "" };
}

export const MsgTransferServiceOwnership: MessageFns<MsgTransferServiceOwnership> = {
  encode(message: MsgTransferServiceOwnership, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.serviceId !== 0) {
      writer.uint32(16).uint32(message.serviceId);
    }
    if (message.newAdmin !== "") {
      writer.uint32(26).string(message.newAdmin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransferServiceOwnership {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferServiceOwnership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newAdmin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTransferServiceOwnership {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      serviceId: isSet(object.serviceId) ? gt.Number(object.serviceId) : 0,
      newAdmin: isSet(object.newAdmin) ? gt.String(object.newAdmin) : "",
    };
  },

  toJSON(message: MsgTransferServiceOwnership): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    if (message.newAdmin !== "") {
      obj.newAdmin = message.newAdmin;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgTransferServiceOwnership>): MsgTransferServiceOwnership {
    return MsgTransferServiceOwnership.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgTransferServiceOwnership>): MsgTransferServiceOwnership {
    const message = createBaseMsgTransferServiceOwnership();
    message.sender = object.sender ?? "";
    message.serviceId = object.serviceId ?? 0;
    message.newAdmin = object.newAdmin ?? "";
    return message;
  },
};

function createBaseMsgTransferServiceOwnershipResponse(): MsgTransferServiceOwnershipResponse {
  return {};
}

export const MsgTransferServiceOwnershipResponse: MessageFns<MsgTransferServiceOwnershipResponse> = {
  encode(_: MsgTransferServiceOwnershipResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransferServiceOwnershipResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferServiceOwnershipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTransferServiceOwnershipResponse {
    return {};
  },

  toJSON(_: MsgTransferServiceOwnershipResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTransferServiceOwnershipResponse>): MsgTransferServiceOwnershipResponse {
    return MsgTransferServiceOwnershipResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgTransferServiceOwnershipResponse>): MsgTransferServiceOwnershipResponse {
    const message = createBaseMsgTransferServiceOwnershipResponse();
    return message;
  },
};

function createBaseMsgSetServiceParams(): MsgSetServiceParams {
  return { sender: "", serviceId: 0, serviceParams: undefined };
}

export const MsgSetServiceParams: MessageFns<MsgSetServiceParams> = {
  encode(message: MsgSetServiceParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.serviceId !== 0) {
      writer.uint32(16).uint32(message.serviceId);
    }
    if (message.serviceParams !== undefined) {
      ServiceParams.encode(message.serviceParams, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetServiceParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetServiceParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serviceParams = ServiceParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetServiceParams {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      serviceId: isSet(object.serviceId) ? gt.Number(object.serviceId) : 0,
      serviceParams: isSet(object.serviceParams) ? ServiceParams.fromJSON(object.serviceParams) : undefined,
    };
  },

  toJSON(message: MsgSetServiceParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    if (message.serviceParams !== undefined) {
      obj.serviceParams = ServiceParams.toJSON(message.serviceParams);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSetServiceParams>): MsgSetServiceParams {
    return MsgSetServiceParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSetServiceParams>): MsgSetServiceParams {
    const message = createBaseMsgSetServiceParams();
    message.sender = object.sender ?? "";
    message.serviceId = object.serviceId ?? 0;
    message.serviceParams = (object.serviceParams !== undefined && object.serviceParams !== null)
      ? ServiceParams.fromPartial(object.serviceParams)
      : undefined;
    return message;
  },
};

function createBaseMsgSetServiceParamsResponse(): MsgSetServiceParamsResponse {
  return {};
}

export const MsgSetServiceParamsResponse: MessageFns<MsgSetServiceParamsResponse> = {
  encode(_: MsgSetServiceParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetServiceParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetServiceParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetServiceParamsResponse {
    return {};
  },

  toJSON(_: MsgSetServiceParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSetServiceParamsResponse>): MsgSetServiceParamsResponse {
    return MsgSetServiceParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSetServiceParamsResponse>): MsgSetServiceParamsResponse {
    const message = createBaseMsgSetServiceParamsResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? gt.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgAccreditService(): MsgAccreditService {
  return { authority: "", serviceId: 0 };
}

export const MsgAccreditService: MessageFns<MsgAccreditService> = {
  encode(message: MsgAccreditService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.serviceId !== 0) {
      writer.uint32(16).uint32(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAccreditService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAccreditService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAccreditService {
    return {
      authority: isSet(object.authority) ? gt.String(object.authority) : "",
      serviceId: isSet(object.serviceId) ? gt.Number(object.serviceId) : 0,
    };
  },

  toJSON(message: MsgAccreditService): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgAccreditService>): MsgAccreditService {
    return MsgAccreditService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgAccreditService>): MsgAccreditService {
    const message = createBaseMsgAccreditService();
    message.authority = object.authority ?? "";
    message.serviceId = object.serviceId ?? 0;
    return message;
  },
};

function createBaseMsgAccreditServiceResponse(): MsgAccreditServiceResponse {
  return {};
}

export const MsgAccreditServiceResponse: MessageFns<MsgAccreditServiceResponse> = {
  encode(_: MsgAccreditServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAccreditServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAccreditServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAccreditServiceResponse {
    return {};
  },

  toJSON(_: MsgAccreditServiceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAccreditServiceResponse>): MsgAccreditServiceResponse {
    return MsgAccreditServiceResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgAccreditServiceResponse>): MsgAccreditServiceResponse {
    const message = createBaseMsgAccreditServiceResponse();
    return message;
  },
};

function createBaseMsgRevokeServiceAccreditation(): MsgRevokeServiceAccreditation {
  return { authority: "", serviceId: 0 };
}

export const MsgRevokeServiceAccreditation: MessageFns<MsgRevokeServiceAccreditation> = {
  encode(message: MsgRevokeServiceAccreditation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.serviceId !== 0) {
      writer.uint32(16).uint32(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeServiceAccreditation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeServiceAccreditation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRevokeServiceAccreditation {
    return {
      authority: isSet(object.authority) ? gt.String(object.authority) : "",
      serviceId: isSet(object.serviceId) ? gt.Number(object.serviceId) : 0,
    };
  },

  toJSON(message: MsgRevokeServiceAccreditation): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRevokeServiceAccreditation>): MsgRevokeServiceAccreditation {
    return MsgRevokeServiceAccreditation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRevokeServiceAccreditation>): MsgRevokeServiceAccreditation {
    const message = createBaseMsgRevokeServiceAccreditation();
    message.authority = object.authority ?? "";
    message.serviceId = object.serviceId ?? 0;
    return message;
  },
};

function createBaseMsgRevokeServiceAccreditationResponse(): MsgRevokeServiceAccreditationResponse {
  return {};
}

export const MsgRevokeServiceAccreditationResponse: MessageFns<MsgRevokeServiceAccreditationResponse> = {
  encode(_: MsgRevokeServiceAccreditationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeServiceAccreditationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeServiceAccreditationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRevokeServiceAccreditationResponse {
    return {};
  },

  toJSON(_: MsgRevokeServiceAccreditationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRevokeServiceAccreditationResponse>): MsgRevokeServiceAccreditationResponse {
    return MsgRevokeServiceAccreditationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRevokeServiceAccreditationResponse>): MsgRevokeServiceAccreditationResponse {
    const message = createBaseMsgRevokeServiceAccreditationResponse();
    return message;
  },
};

/** Msg defines the services module's gRPC message service. */
export interface Msg {
  /** CreateService defines the operation for registering a new service. */
  CreateService(request: MsgCreateService): Promise<MsgCreateServiceResponse>;
  /** UpdateService defines the operation for updating an existing service. */
  UpdateService(request: MsgUpdateService): Promise<MsgUpdateServiceResponse>;
  /**
   * ActivateService defines the operation for activating an existing
   * service.
   */
  ActivateService(request: MsgActivateService): Promise<MsgActivateServiceResponse>;
  /**
   * DeactivateService defines the operation for deactivating an existing
   * service.
   */
  DeactivateService(request: MsgDeactivateService): Promise<MsgDeactivateServiceResponse>;
  /**
   * DeleteService defines the operation for deleting an existing service
   * that has been deactivated.
   */
  DeleteService(request: MsgDeleteService): Promise<MsgDeleteServiceResponse>;
  /**
   * TransferServiceOwnership defines the operation for transferring the
   * ownership of a service to another account.
   */
  TransferServiceOwnership(request: MsgTransferServiceOwnership): Promise<MsgTransferServiceOwnershipResponse>;
  /**
   * SetServiceParams defines the operation for setting a service's
   * parameters.
   */
  SetServiceParams(request: MsgSetServiceParams): Promise<MsgSetServiceParamsResponse>;
  /**
   * UpdateParams defines a (governance) operation for updating the module
   * parameters.
   * The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  /**
   * AccreditService defines a (governance) operation for accrediting a service.
   * Since: v1.4.0
   */
  AccreditService(request: MsgAccreditService): Promise<MsgAccreditServiceResponse>;
  /**
   * RevokeServiceAccreditation defines a (governance) operation for revoking a
   * service's accreditation. Since: v1.4.0
   */
  RevokeServiceAccreditation(request: MsgRevokeServiceAccreditation): Promise<MsgRevokeServiceAccreditationResponse>;
}

export const MsgServiceName = "milkyway.services.v1.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.CreateService = this.CreateService.bind(this);
    this.UpdateService = this.UpdateService.bind(this);
    this.ActivateService = this.ActivateService.bind(this);
    this.DeactivateService = this.DeactivateService.bind(this);
    this.DeleteService = this.DeleteService.bind(this);
    this.TransferServiceOwnership = this.TransferServiceOwnership.bind(this);
    this.SetServiceParams = this.SetServiceParams.bind(this);
    this.UpdateParams = this.UpdateParams.bind(this);
    this.AccreditService = this.AccreditService.bind(this);
    this.RevokeServiceAccreditation = this.RevokeServiceAccreditation.bind(this);
  }
  CreateService(request: MsgCreateService): Promise<MsgCreateServiceResponse> {
    const data = MsgCreateService.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateService", data);
    return promise.then((data) => MsgCreateServiceResponse.decode(new BinaryReader(data)));
  }

  UpdateService(request: MsgUpdateService): Promise<MsgUpdateServiceResponse> {
    const data = MsgUpdateService.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateService", data);
    return promise.then((data) => MsgUpdateServiceResponse.decode(new BinaryReader(data)));
  }

  ActivateService(request: MsgActivateService): Promise<MsgActivateServiceResponse> {
    const data = MsgActivateService.encode(request).finish();
    const promise = this.rpc.request(this.service, "ActivateService", data);
    return promise.then((data) => MsgActivateServiceResponse.decode(new BinaryReader(data)));
  }

  DeactivateService(request: MsgDeactivateService): Promise<MsgDeactivateServiceResponse> {
    const data = MsgDeactivateService.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeactivateService", data);
    return promise.then((data) => MsgDeactivateServiceResponse.decode(new BinaryReader(data)));
  }

  DeleteService(request: MsgDeleteService): Promise<MsgDeleteServiceResponse> {
    const data = MsgDeleteService.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteService", data);
    return promise.then((data) => MsgDeleteServiceResponse.decode(new BinaryReader(data)));
  }

  TransferServiceOwnership(request: MsgTransferServiceOwnership): Promise<MsgTransferServiceOwnershipResponse> {
    const data = MsgTransferServiceOwnership.encode(request).finish();
    const promise = this.rpc.request(this.service, "TransferServiceOwnership", data);
    return promise.then((data) => MsgTransferServiceOwnershipResponse.decode(new BinaryReader(data)));
  }

  SetServiceParams(request: MsgSetServiceParams): Promise<MsgSetServiceParamsResponse> {
    const data = MsgSetServiceParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetServiceParams", data);
    return promise.then((data) => MsgSetServiceParamsResponse.decode(new BinaryReader(data)));
  }

  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  AccreditService(request: MsgAccreditService): Promise<MsgAccreditServiceResponse> {
    const data = MsgAccreditService.encode(request).finish();
    const promise = this.rpc.request(this.service, "AccreditService", data);
    return promise.then((data) => MsgAccreditServiceResponse.decode(new BinaryReader(data)));
  }

  RevokeServiceAccreditation(request: MsgRevokeServiceAccreditation): Promise<MsgRevokeServiceAccreditationResponse> {
    const data = MsgRevokeServiceAccreditation.encode(request).finish();
    const promise = this.rpc.request(this.service, "RevokeServiceAccreditation", data);
    return promise.then((data) => MsgRevokeServiceAccreditationResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
