// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: milkyway/pools/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { Pool } from "./models";

export const protobufPackage = "milkyway.pools.v1";

/** QueryPoolByIdRequest is the request type for the Query/PoolById RPC method. */
export interface QueryPoolByIdRequest {
  /** PoolID is the ID of the pool to query */
  poolId: number;
}

/**
 * QueryPoolByDenomRequest is the request type for the Query/PollByDenom RPC
 * method.
 */
export interface QueryPoolByDenomRequest {
  /** Denom is the denom for which the pool is to be queried */
  denom: string;
}

/**
 * QueryPoolResponse is the response type for the Query/PoolById and
 * Query/PoolByDenom RPC methods.
 */
export interface QueryPoolResponse {
  /** Pool is the queried pool */
  pool: Pool | undefined;
}

/** QueryPoolsRequest is the request type for the Query/Pools RPC method. */
export interface QueryPoolsRequest {
  pagination: PageRequest | undefined;
}

/** QueryPoolsResponse is the response type for the Query/Pools RPC method. */
export interface QueryPoolsResponse {
  /** Pools is the list of pool */
  pools: Pool[];
  /** Pagination defines the pagination response */
  pagination: PageResponse | undefined;
}

function createBaseQueryPoolByIdRequest(): QueryPoolByIdRequest {
  return { poolId: 0 };
}

export const QueryPoolByIdRequest: MessageFns<QueryPoolByIdRequest> = {
  encode(message: QueryPoolByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.poolId !== 0) {
      writer.uint32(8).uint32(message.poolId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.poolId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolByIdRequest {
    return { poolId: isSet(object.poolId) ? gt.Number(object.poolId) : 0 };
  },

  toJSON(message: QueryPoolByIdRequest): unknown {
    const obj: any = {};
    if (message.poolId !== 0) {
      obj.poolId = Math.round(message.poolId);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPoolByIdRequest>): QueryPoolByIdRequest {
    return QueryPoolByIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPoolByIdRequest>): QueryPoolByIdRequest {
    const message = createBaseQueryPoolByIdRequest();
    message.poolId = object.poolId ?? 0;
    return message;
  },
};

function createBaseQueryPoolByDenomRequest(): QueryPoolByDenomRequest {
  return { denom: "" };
}

export const QueryPoolByDenomRequest: MessageFns<QueryPoolByDenomRequest> = {
  encode(message: QueryPoolByDenomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolByDenomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolByDenomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolByDenomRequest {
    return { denom: isSet(object.denom) ? gt.String(object.denom) : "" };
  },

  toJSON(message: QueryPoolByDenomRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPoolByDenomRequest>): QueryPoolByDenomRequest {
    return QueryPoolByDenomRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPoolByDenomRequest>): QueryPoolByDenomRequest {
    const message = createBaseQueryPoolByDenomRequest();
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseQueryPoolResponse(): QueryPoolResponse {
  return { pool: undefined };
}

export const QueryPoolResponse: MessageFns<QueryPoolResponse> = {
  encode(message: QueryPoolResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pool !== undefined) {
      Pool.encode(message.pool, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pool = Pool.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolResponse {
    return { pool: isSet(object.pool) ? Pool.fromJSON(object.pool) : undefined };
  },

  toJSON(message: QueryPoolResponse): unknown {
    const obj: any = {};
    if (message.pool !== undefined) {
      obj.pool = Pool.toJSON(message.pool);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPoolResponse>): QueryPoolResponse {
    return QueryPoolResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPoolResponse>): QueryPoolResponse {
    const message = createBaseQueryPoolResponse();
    message.pool = (object.pool !== undefined && object.pool !== null) ? Pool.fromPartial(object.pool) : undefined;
    return message;
  },
};

function createBaseQueryPoolsRequest(): QueryPoolsRequest {
  return { pagination: undefined };
}

export const QueryPoolsRequest: MessageFns<QueryPoolsRequest> = {
  encode(message: QueryPoolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryPoolsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPoolsRequest>): QueryPoolsRequest {
    return QueryPoolsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPoolsRequest>): QueryPoolsRequest {
    const message = createBaseQueryPoolsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryPoolsResponse(): QueryPoolsResponse {
  return { pools: [], pagination: undefined };
}

export const QueryPoolsResponse: MessageFns<QueryPoolsResponse> = {
  encode(message: QueryPoolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pools) {
      Pool.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pools.push(Pool.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolsResponse {
    return {
      pools: gt.Array.isArray(object?.pools) ? object.pools.map((e: any) => Pool.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryPoolsResponse): unknown {
    const obj: any = {};
    if (message.pools?.length) {
      obj.pools = message.pools.map((e) => Pool.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPoolsResponse>): QueryPoolsResponse {
    return QueryPoolsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPoolsResponse>): QueryPoolsResponse {
    const message = createBaseQueryPoolsResponse();
    message.pools = object.pools?.map((e) => Pool.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** PoolByID defines a gRPC query method that returns the pool by the given ID. */
  PoolByID(request: QueryPoolByIdRequest): Promise<QueryPoolResponse>;
  /**
   * PoolByDenom defines a gRPC query method that returns the pool by the given
   * denom.
   */
  PoolByDenom(request: QueryPoolByDenomRequest): Promise<QueryPoolResponse>;
  /** Pools defines a gRPC query method that returns all pools. */
  Pools(request: QueryPoolsRequest): Promise<QueryPoolsResponse>;
}

export const QueryServiceName = "milkyway.pools.v1.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.PoolByID = this.PoolByID.bind(this);
    this.PoolByDenom = this.PoolByDenom.bind(this);
    this.Pools = this.Pools.bind(this);
  }
  PoolByID(request: QueryPoolByIdRequest): Promise<QueryPoolResponse> {
    const data = QueryPoolByIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PoolByID", data);
    return promise.then((data) => QueryPoolResponse.decode(new BinaryReader(data)));
  }

  PoolByDenom(request: QueryPoolByDenomRequest): Promise<QueryPoolResponse> {
    const data = QueryPoolByDenomRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PoolByDenom", data);
    return promise.then((data) => QueryPoolResponse.decode(new BinaryReader(data)));
  }

  Pools(request: QueryPoolsRequest): Promise<QueryPoolsResponse> {
    const data = QueryPoolsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Pools", data);
    return promise.then((data) => QueryPoolsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
