// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: milkyway/rewards/v1/genesis.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";
import {
  AccumulatedCommission,
  CurrentRewards,
  DecPool,
  DelegatorStartingInfo,
  HistoricalRewards,
  PoolServiceTotalDelegatorShares,
  RewardsPlan,
} from "./models";
import { Params } from "./params";

export const protobufPackage = "milkyway.rewards.v1";

/**
 * DelegatorWithdrawInfo is the address for where delegation rewards are
 * withdrawn to by default this struct is only used at genesis to feed in
 * default withdraw addresses.
 */
export interface DelegatorWithdrawInfo {
  /** delegator_address is the address of the delegator. */
  delegatorAddress: string;
  /** withdraw_address is the address to withdraw the delegation rewards to. */
  withdrawAddress: string;
}

/** OutstandingRewardsRecord is used for import/export via genesis json. */
export interface OutstandingRewardsRecord {
  /** delegation_target_id is the ID of the delegation target. */
  delegationTargetId: number;
  /**
   * outstanding_rewards represents the outstanding rewards of the delegation
   * target.
   */
  outstandingRewards: DecPool[];
}

/**
 * HistoricalRewardsRecord is used for import / export via genesis
 * json.
 */
export interface HistoricalRewardsRecord {
  /** delegation_target_id is the ID of the delegation target. */
  delegationTargetId: number;
  /** period defines the period the historical rewards apply to. */
  period: number;
  /** rewards defines the historical rewards of the delegation target. */
  rewards: HistoricalRewards | undefined;
}

/** CurrentRewardsRecord is used for import / export via genesis json. */
export interface CurrentRewardsRecord {
  /** delegation_target_id is the ID of the delegation target. */
  delegationTargetId: number;
  /** rewards defines the current rewards of the delegation target. */
  rewards: CurrentRewards | undefined;
}

/** DelegatorStartingInfoRecord used for import / export via genesis json. */
export interface DelegatorStartingInfoRecord {
  /** delegator_address is the address of the delegator. */
  delegatorAddress: string;
  /** delegation_target_id is the ID of the delegation target. */
  delegationTargetId: number;
  /** starting_info defines the starting info of a delegator. */
  startingInfo: DelegatorStartingInfo | undefined;
}

export interface OperatorAccumulatedCommissionRecord {
  operatorId: number;
  /** accumulated is the accumulated commission of an operator. */
  accumulated: AccumulatedCommission | undefined;
}

/**
 * DelegationTypeRecords groups various genesis records under the same type
 * of delegation target.
 */
export interface DelegationTypeRecords {
  /**
   * outstanding_rewards defines the outstanding rewards of all delegation
   * targets with the same delegation type at genesis.
   */
  outstandingRewards: OutstandingRewardsRecord[];
  /**
   * historical_rewards defines the historical rewards of all delegation targets
   * with the same delegation type at genesis.
   */
  historicalRewards: HistoricalRewardsRecord[];
  /**
   * current_rewards defines the current rewards of all delegation targets with
   * the same delegation type at genesis.
   */
  currentRewards: CurrentRewardsRecord[];
  /**
   * delegator_starting_infos defines the delegator starting infos of all
   * delegation targets with the same delegation type at genesis.
   */
  delegatorStartingInfos: DelegatorStartingInfoRecord[];
}

/** GenesisState defines the module's genesis state. */
export interface GenesisState {
  /** Params defines the parameters of the module. */
  params:
    | Params
    | undefined;
  /**
   * NextRewardsPlanID represents the id to be used when creating the next
   * rewards plan.
   */
  nextRewardsPlanId: number;
  /** RewardsPlans defines the list of rewards plans. */
  rewardsPlans: RewardsPlan[];
  /** last_rewards_allocation_time is the last time rewards were allocated. */
  lastRewardsAllocationTime:
    | Date
    | undefined;
  /** delegator_withdraw_infos defines the delegator withdraw infos at genesis. */
  delegatorWithdrawInfos: DelegatorWithdrawInfo[];
  /** pools_records defines a group of genesis records of all pools at genesis. */
  poolsRecords:
    | DelegationTypeRecords
    | undefined;
  /**
   * operators_records defines a group of genesis records of all operators at
   * genesis.
   */
  operatorsRecords:
    | DelegationTypeRecords
    | undefined;
  /**
   * services_records defines a group of genesis records of all services at
   * genesis.
   */
  servicesRecords:
    | DelegationTypeRecords
    | undefined;
  /**
   * operator_accumulated_commissions defines the accumulated commissions of all
   * operators at genesis.
   */
  operatorAccumulatedCommissions: OperatorAccumulatedCommissionRecord[];
  /**
   * pool_service_total_delegator_shares defines the total delegator shares at
   * genesis.
   */
  poolServiceTotalDelegatorShares: PoolServiceTotalDelegatorShares[];
}

function createBaseDelegatorWithdrawInfo(): DelegatorWithdrawInfo {
  return { delegatorAddress: "", withdrawAddress: "" };
}

export const DelegatorWithdrawInfo: MessageFns<DelegatorWithdrawInfo> = {
  encode(message: DelegatorWithdrawInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delegatorAddress !== "") {
      writer.uint32(10).string(message.delegatorAddress);
    }
    if (message.withdrawAddress !== "") {
      writer.uint32(18).string(message.withdrawAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DelegatorWithdrawInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegatorWithdrawInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delegatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.withdrawAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DelegatorWithdrawInfo {
    return {
      delegatorAddress: isSet(object.delegatorAddress) ? gt.String(object.delegatorAddress) : "",
      withdrawAddress: isSet(object.withdrawAddress) ? gt.String(object.withdrawAddress) : "",
    };
  },

  toJSON(message: DelegatorWithdrawInfo): unknown {
    const obj: any = {};
    if (message.delegatorAddress !== "") {
      obj.delegatorAddress = message.delegatorAddress;
    }
    if (message.withdrawAddress !== "") {
      obj.withdrawAddress = message.withdrawAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<DelegatorWithdrawInfo>): DelegatorWithdrawInfo {
    return DelegatorWithdrawInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DelegatorWithdrawInfo>): DelegatorWithdrawInfo {
    const message = createBaseDelegatorWithdrawInfo();
    message.delegatorAddress = object.delegatorAddress ?? "";
    message.withdrawAddress = object.withdrawAddress ?? "";
    return message;
  },
};

function createBaseOutstandingRewardsRecord(): OutstandingRewardsRecord {
  return { delegationTargetId: 0, outstandingRewards: [] };
}

export const OutstandingRewardsRecord: MessageFns<OutstandingRewardsRecord> = {
  encode(message: OutstandingRewardsRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delegationTargetId !== 0) {
      writer.uint32(8).uint32(message.delegationTargetId);
    }
    for (const v of message.outstandingRewards) {
      DecPool.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutstandingRewardsRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutstandingRewardsRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.delegationTargetId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outstandingRewards.push(DecPool.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutstandingRewardsRecord {
    return {
      delegationTargetId: isSet(object.delegationTargetId) ? gt.Number(object.delegationTargetId) : 0,
      outstandingRewards: gt.Array.isArray(object?.outstandingRewards)
        ? object.outstandingRewards.map((e: any) => DecPool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OutstandingRewardsRecord): unknown {
    const obj: any = {};
    if (message.delegationTargetId !== 0) {
      obj.delegationTargetId = Math.round(message.delegationTargetId);
    }
    if (message.outstandingRewards?.length) {
      obj.outstandingRewards = message.outstandingRewards.map((e) => DecPool.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OutstandingRewardsRecord>): OutstandingRewardsRecord {
    return OutstandingRewardsRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutstandingRewardsRecord>): OutstandingRewardsRecord {
    const message = createBaseOutstandingRewardsRecord();
    message.delegationTargetId = object.delegationTargetId ?? 0;
    message.outstandingRewards = object.outstandingRewards?.map((e) => DecPool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHistoricalRewardsRecord(): HistoricalRewardsRecord {
  return { delegationTargetId: 0, period: 0, rewards: undefined };
}

export const HistoricalRewardsRecord: MessageFns<HistoricalRewardsRecord> = {
  encode(message: HistoricalRewardsRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delegationTargetId !== 0) {
      writer.uint32(8).uint32(message.delegationTargetId);
    }
    if (message.period !== 0) {
      writer.uint32(16).uint64(message.period);
    }
    if (message.rewards !== undefined) {
      HistoricalRewards.encode(message.rewards, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistoricalRewardsRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistoricalRewardsRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.delegationTargetId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.period = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rewards = HistoricalRewards.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistoricalRewardsRecord {
    return {
      delegationTargetId: isSet(object.delegationTargetId) ? gt.Number(object.delegationTargetId) : 0,
      period: isSet(object.period) ? gt.Number(object.period) : 0,
      rewards: isSet(object.rewards) ? HistoricalRewards.fromJSON(object.rewards) : undefined,
    };
  },

  toJSON(message: HistoricalRewardsRecord): unknown {
    const obj: any = {};
    if (message.delegationTargetId !== 0) {
      obj.delegationTargetId = Math.round(message.delegationTargetId);
    }
    if (message.period !== 0) {
      obj.period = Math.round(message.period);
    }
    if (message.rewards !== undefined) {
      obj.rewards = HistoricalRewards.toJSON(message.rewards);
    }
    return obj;
  },

  create(base?: DeepPartial<HistoricalRewardsRecord>): HistoricalRewardsRecord {
    return HistoricalRewardsRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HistoricalRewardsRecord>): HistoricalRewardsRecord {
    const message = createBaseHistoricalRewardsRecord();
    message.delegationTargetId = object.delegationTargetId ?? 0;
    message.period = object.period ?? 0;
    message.rewards = (object.rewards !== undefined && object.rewards !== null)
      ? HistoricalRewards.fromPartial(object.rewards)
      : undefined;
    return message;
  },
};

function createBaseCurrentRewardsRecord(): CurrentRewardsRecord {
  return { delegationTargetId: 0, rewards: undefined };
}

export const CurrentRewardsRecord: MessageFns<CurrentRewardsRecord> = {
  encode(message: CurrentRewardsRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delegationTargetId !== 0) {
      writer.uint32(8).uint32(message.delegationTargetId);
    }
    if (message.rewards !== undefined) {
      CurrentRewards.encode(message.rewards, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CurrentRewardsRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrentRewardsRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.delegationTargetId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rewards = CurrentRewards.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrentRewardsRecord {
    return {
      delegationTargetId: isSet(object.delegationTargetId) ? gt.Number(object.delegationTargetId) : 0,
      rewards: isSet(object.rewards) ? CurrentRewards.fromJSON(object.rewards) : undefined,
    };
  },

  toJSON(message: CurrentRewardsRecord): unknown {
    const obj: any = {};
    if (message.delegationTargetId !== 0) {
      obj.delegationTargetId = Math.round(message.delegationTargetId);
    }
    if (message.rewards !== undefined) {
      obj.rewards = CurrentRewards.toJSON(message.rewards);
    }
    return obj;
  },

  create(base?: DeepPartial<CurrentRewardsRecord>): CurrentRewardsRecord {
    return CurrentRewardsRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CurrentRewardsRecord>): CurrentRewardsRecord {
    const message = createBaseCurrentRewardsRecord();
    message.delegationTargetId = object.delegationTargetId ?? 0;
    message.rewards = (object.rewards !== undefined && object.rewards !== null)
      ? CurrentRewards.fromPartial(object.rewards)
      : undefined;
    return message;
  },
};

function createBaseDelegatorStartingInfoRecord(): DelegatorStartingInfoRecord {
  return { delegatorAddress: "", delegationTargetId: 0, startingInfo: undefined };
}

export const DelegatorStartingInfoRecord: MessageFns<DelegatorStartingInfoRecord> = {
  encode(message: DelegatorStartingInfoRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delegatorAddress !== "") {
      writer.uint32(10).string(message.delegatorAddress);
    }
    if (message.delegationTargetId !== 0) {
      writer.uint32(16).uint32(message.delegationTargetId);
    }
    if (message.startingInfo !== undefined) {
      DelegatorStartingInfo.encode(message.startingInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DelegatorStartingInfoRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegatorStartingInfoRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delegatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.delegationTargetId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startingInfo = DelegatorStartingInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DelegatorStartingInfoRecord {
    return {
      delegatorAddress: isSet(object.delegatorAddress) ? gt.String(object.delegatorAddress) : "",
      delegationTargetId: isSet(object.delegationTargetId) ? gt.Number(object.delegationTargetId) : 0,
      startingInfo: isSet(object.startingInfo) ? DelegatorStartingInfo.fromJSON(object.startingInfo) : undefined,
    };
  },

  toJSON(message: DelegatorStartingInfoRecord): unknown {
    const obj: any = {};
    if (message.delegatorAddress !== "") {
      obj.delegatorAddress = message.delegatorAddress;
    }
    if (message.delegationTargetId !== 0) {
      obj.delegationTargetId = Math.round(message.delegationTargetId);
    }
    if (message.startingInfo !== undefined) {
      obj.startingInfo = DelegatorStartingInfo.toJSON(message.startingInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<DelegatorStartingInfoRecord>): DelegatorStartingInfoRecord {
    return DelegatorStartingInfoRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DelegatorStartingInfoRecord>): DelegatorStartingInfoRecord {
    const message = createBaseDelegatorStartingInfoRecord();
    message.delegatorAddress = object.delegatorAddress ?? "";
    message.delegationTargetId = object.delegationTargetId ?? 0;
    message.startingInfo = (object.startingInfo !== undefined && object.startingInfo !== null)
      ? DelegatorStartingInfo.fromPartial(object.startingInfo)
      : undefined;
    return message;
  },
};

function createBaseOperatorAccumulatedCommissionRecord(): OperatorAccumulatedCommissionRecord {
  return { operatorId: 0, accumulated: undefined };
}

export const OperatorAccumulatedCommissionRecord: MessageFns<OperatorAccumulatedCommissionRecord> = {
  encode(message: OperatorAccumulatedCommissionRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operatorId !== 0) {
      writer.uint32(8).uint32(message.operatorId);
    }
    if (message.accumulated !== undefined) {
      AccumulatedCommission.encode(message.accumulated, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperatorAccumulatedCommissionRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorAccumulatedCommissionRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.operatorId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accumulated = AccumulatedCommission.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorAccumulatedCommissionRecord {
    return {
      operatorId: isSet(object.operatorId) ? gt.Number(object.operatorId) : 0,
      accumulated: isSet(object.accumulated) ? AccumulatedCommission.fromJSON(object.accumulated) : undefined,
    };
  },

  toJSON(message: OperatorAccumulatedCommissionRecord): unknown {
    const obj: any = {};
    if (message.operatorId !== 0) {
      obj.operatorId = Math.round(message.operatorId);
    }
    if (message.accumulated !== undefined) {
      obj.accumulated = AccumulatedCommission.toJSON(message.accumulated);
    }
    return obj;
  },

  create(base?: DeepPartial<OperatorAccumulatedCommissionRecord>): OperatorAccumulatedCommissionRecord {
    return OperatorAccumulatedCommissionRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperatorAccumulatedCommissionRecord>): OperatorAccumulatedCommissionRecord {
    const message = createBaseOperatorAccumulatedCommissionRecord();
    message.operatorId = object.operatorId ?? 0;
    message.accumulated = (object.accumulated !== undefined && object.accumulated !== null)
      ? AccumulatedCommission.fromPartial(object.accumulated)
      : undefined;
    return message;
  },
};

function createBaseDelegationTypeRecords(): DelegationTypeRecords {
  return { outstandingRewards: [], historicalRewards: [], currentRewards: [], delegatorStartingInfos: [] };
}

export const DelegationTypeRecords: MessageFns<DelegationTypeRecords> = {
  encode(message: DelegationTypeRecords, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outstandingRewards) {
      OutstandingRewardsRecord.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.historicalRewards) {
      HistoricalRewardsRecord.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.currentRewards) {
      CurrentRewardsRecord.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.delegatorStartingInfos) {
      DelegatorStartingInfoRecord.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DelegationTypeRecords {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegationTypeRecords();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outstandingRewards.push(OutstandingRewardsRecord.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.historicalRewards.push(HistoricalRewardsRecord.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentRewards.push(CurrentRewardsRecord.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.delegatorStartingInfos.push(DelegatorStartingInfoRecord.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DelegationTypeRecords {
    return {
      outstandingRewards: gt.Array.isArray(object?.outstandingRewards)
        ? object.outstandingRewards.map((e: any) => OutstandingRewardsRecord.fromJSON(e))
        : [],
      historicalRewards: gt.Array.isArray(object?.historicalRewards)
        ? object.historicalRewards.map((e: any) => HistoricalRewardsRecord.fromJSON(e))
        : [],
      currentRewards: gt.Array.isArray(object?.currentRewards)
        ? object.currentRewards.map((e: any) => CurrentRewardsRecord.fromJSON(e))
        : [],
      delegatorStartingInfos: gt.Array.isArray(object?.delegatorStartingInfos)
        ? object.delegatorStartingInfos.map((e: any) => DelegatorStartingInfoRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DelegationTypeRecords): unknown {
    const obj: any = {};
    if (message.outstandingRewards?.length) {
      obj.outstandingRewards = message.outstandingRewards.map((e) => OutstandingRewardsRecord.toJSON(e));
    }
    if (message.historicalRewards?.length) {
      obj.historicalRewards = message.historicalRewards.map((e) => HistoricalRewardsRecord.toJSON(e));
    }
    if (message.currentRewards?.length) {
      obj.currentRewards = message.currentRewards.map((e) => CurrentRewardsRecord.toJSON(e));
    }
    if (message.delegatorStartingInfos?.length) {
      obj.delegatorStartingInfos = message.delegatorStartingInfos.map((e) => DelegatorStartingInfoRecord.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DelegationTypeRecords>): DelegationTypeRecords {
    return DelegationTypeRecords.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DelegationTypeRecords>): DelegationTypeRecords {
    const message = createBaseDelegationTypeRecords();
    message.outstandingRewards = object.outstandingRewards?.map((e) => OutstandingRewardsRecord.fromPartial(e)) || [];
    message.historicalRewards = object.historicalRewards?.map((e) => HistoricalRewardsRecord.fromPartial(e)) || [];
    message.currentRewards = object.currentRewards?.map((e) => CurrentRewardsRecord.fromPartial(e)) || [];
    message.delegatorStartingInfos =
      object.delegatorStartingInfos?.map((e) => DelegatorStartingInfoRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenesisState(): GenesisState {
  return {
    params: undefined,
    nextRewardsPlanId: 0,
    rewardsPlans: [],
    lastRewardsAllocationTime: undefined,
    delegatorWithdrawInfos: [],
    poolsRecords: undefined,
    operatorsRecords: undefined,
    servicesRecords: undefined,
    operatorAccumulatedCommissions: [],
    poolServiceTotalDelegatorShares: [],
  };
}

export const GenesisState: MessageFns<GenesisState> = {
  encode(message: GenesisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.nextRewardsPlanId !== 0) {
      writer.uint32(16).uint64(message.nextRewardsPlanId);
    }
    for (const v of message.rewardsPlans) {
      RewardsPlan.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.lastRewardsAllocationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastRewardsAllocationTime), writer.uint32(34).fork()).join();
    }
    for (const v of message.delegatorWithdrawInfos) {
      DelegatorWithdrawInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.poolsRecords !== undefined) {
      DelegationTypeRecords.encode(message.poolsRecords, writer.uint32(50).fork()).join();
    }
    if (message.operatorsRecords !== undefined) {
      DelegationTypeRecords.encode(message.operatorsRecords, writer.uint32(58).fork()).join();
    }
    if (message.servicesRecords !== undefined) {
      DelegationTypeRecords.encode(message.servicesRecords, writer.uint32(66).fork()).join();
    }
    for (const v of message.operatorAccumulatedCommissions) {
      OperatorAccumulatedCommissionRecord.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.poolServiceTotalDelegatorShares) {
      PoolServiceTotalDelegatorShares.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenesisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nextRewardsPlanId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rewardsPlans.push(RewardsPlan.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastRewardsAllocationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.delegatorWithdrawInfos.push(DelegatorWithdrawInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.poolsRecords = DelegationTypeRecords.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.operatorsRecords = DelegationTypeRecords.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.servicesRecords = DelegationTypeRecords.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.operatorAccumulatedCommissions.push(
            OperatorAccumulatedCommissionRecord.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.poolServiceTotalDelegatorShares.push(PoolServiceTotalDelegatorShares.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenesisState {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
      nextRewardsPlanId: isSet(object.nextRewardsPlanId) ? gt.Number(object.nextRewardsPlanId) : 0,
      rewardsPlans: gt.Array.isArray(object?.rewardsPlans)
        ? object.rewardsPlans.map((e: any) => RewardsPlan.fromJSON(e))
        : [],
      lastRewardsAllocationTime: isSet(object.lastRewardsAllocationTime)
        ? fromJsonTimestamp(object.lastRewardsAllocationTime)
        : undefined,
      delegatorWithdrawInfos: gt.Array.isArray(object?.delegatorWithdrawInfos)
        ? object.delegatorWithdrawInfos.map((e: any) => DelegatorWithdrawInfo.fromJSON(e))
        : [],
      poolsRecords: isSet(object.poolsRecords) ? DelegationTypeRecords.fromJSON(object.poolsRecords) : undefined,
      operatorsRecords: isSet(object.operatorsRecords)
        ? DelegationTypeRecords.fromJSON(object.operatorsRecords)
        : undefined,
      servicesRecords: isSet(object.servicesRecords)
        ? DelegationTypeRecords.fromJSON(object.servicesRecords)
        : undefined,
      operatorAccumulatedCommissions: gt.Array.isArray(object?.operatorAccumulatedCommissions)
        ? object.operatorAccumulatedCommissions.map((e: any) => OperatorAccumulatedCommissionRecord.fromJSON(e))
        : [],
      poolServiceTotalDelegatorShares: gt.Array.isArray(object?.poolServiceTotalDelegatorShares)
        ? object.poolServiceTotalDelegatorShares.map((e: any) => PoolServiceTotalDelegatorShares.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenesisState): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    if (message.nextRewardsPlanId !== 0) {
      obj.nextRewardsPlanId = Math.round(message.nextRewardsPlanId);
    }
    if (message.rewardsPlans?.length) {
      obj.rewardsPlans = message.rewardsPlans.map((e) => RewardsPlan.toJSON(e));
    }
    if (message.lastRewardsAllocationTime !== undefined) {
      obj.lastRewardsAllocationTime = message.lastRewardsAllocationTime.toISOString();
    }
    if (message.delegatorWithdrawInfos?.length) {
      obj.delegatorWithdrawInfos = message.delegatorWithdrawInfos.map((e) => DelegatorWithdrawInfo.toJSON(e));
    }
    if (message.poolsRecords !== undefined) {
      obj.poolsRecords = DelegationTypeRecords.toJSON(message.poolsRecords);
    }
    if (message.operatorsRecords !== undefined) {
      obj.operatorsRecords = DelegationTypeRecords.toJSON(message.operatorsRecords);
    }
    if (message.servicesRecords !== undefined) {
      obj.servicesRecords = DelegationTypeRecords.toJSON(message.servicesRecords);
    }
    if (message.operatorAccumulatedCommissions?.length) {
      obj.operatorAccumulatedCommissions = message.operatorAccumulatedCommissions.map((e) =>
        OperatorAccumulatedCommissionRecord.toJSON(e)
      );
    }
    if (message.poolServiceTotalDelegatorShares?.length) {
      obj.poolServiceTotalDelegatorShares = message.poolServiceTotalDelegatorShares.map((e) =>
        PoolServiceTotalDelegatorShares.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<GenesisState>): GenesisState {
    return GenesisState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenesisState>): GenesisState {
    const message = createBaseGenesisState();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    message.nextRewardsPlanId = object.nextRewardsPlanId ?? 0;
    message.rewardsPlans = object.rewardsPlans?.map((e) => RewardsPlan.fromPartial(e)) || [];
    message.lastRewardsAllocationTime = object.lastRewardsAllocationTime ?? undefined;
    message.delegatorWithdrawInfos = object.delegatorWithdrawInfos?.map((e) => DelegatorWithdrawInfo.fromPartial(e)) ||
      [];
    message.poolsRecords = (object.poolsRecords !== undefined && object.poolsRecords !== null)
      ? DelegationTypeRecords.fromPartial(object.poolsRecords)
      : undefined;
    message.operatorsRecords = (object.operatorsRecords !== undefined && object.operatorsRecords !== null)
      ? DelegationTypeRecords.fromPartial(object.operatorsRecords)
      : undefined;
    message.servicesRecords = (object.servicesRecords !== undefined && object.servicesRecords !== null)
      ? DelegationTypeRecords.fromPartial(object.servicesRecords)
      : undefined;
    message.operatorAccumulatedCommissions =
      object.operatorAccumulatedCommissions?.map((e) => OperatorAccumulatedCommissionRecord.fromPartial(e)) || [];
    message.poolServiceTotalDelegatorShares =
      object.poolServiceTotalDelegatorShares?.map((e) => PoolServiceTotalDelegatorShares.fromPartial(e)) || [];
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new gt.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof gt.Date) {
    return o;
  } else if (typeof o === "string") {
    return new gt.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = gt.Number(int64.toString());
  if (num > gt.Number.MAX_SAFE_INTEGER) {
    throw new gt.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < gt.Number.MIN_SAFE_INTEGER) {
    throw new gt.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
