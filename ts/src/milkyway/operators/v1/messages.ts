// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: milkyway/operators/v1/messages.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { OperatorParams } from "./models";
import { Params } from "./params";

export const protobufPackage = "milkyway.operators.v1";

/**
 * MsgRegisterOperator defines the message structure for the RegisterOperator
 * gRPC service method. It allows an account to register a new operator that can
 * opt-in to validate various services. It requires a sender address as well as
 * the details of the operator to be registered.
 */
export interface MsgRegisterOperator {
  /** Sender is the address of the user registering the operator */
  sender: string;
  /** Moniker is the moniker of the operator */
  moniker: string;
  /** Website is the website of the operator (optional) */
  website: string;
  /** PictureURL is the URL of operator picture (optional) */
  pictureUrl: string;
  /**
   * FeeAmount represents the fees that are going to be paid to create the
   * operator. These should always be greater or equals of any of the coins
   * specified inside the OperatorRegistrationFee field of the modules params.
   * If no fees are specified inside the module parameters, this field can be
   * omitted.
   */
  feeAmount: Coin[];
}

/**
 * MsgRegisterOperatorResponse is the return value of MsgRegisterOperator.
 * It returns the newly created operator ID.
 */
export interface MsgRegisterOperatorResponse {
  /** NewOperatorID is the ID of the newly registered operator */
  newOperatorId: number;
}

/**
 * MsgUpdateOperator defines the message structure for the UpdateOperator gRPC
 * service method. It allows the operator owner to update the details of an
 * existing operator.
 */
export interface MsgUpdateOperator {
  /** Sender is the address of the user updating the operator */
  sender: string;
  /** OperatorID represents the ID of the operator to be updated */
  operatorId: number;
  /**
   * Moniker is the new moniker of the operator.
   * If it shouldn't be changed, use [do-not-modify] instead.
   */
  moniker: string;
  /**
   * Website is the new website of the operator.
   * If it shouldn't be changed, use [do-not-modify] instead.
   */
  website: string;
  /**
   * PictureURL is the new URL of the operator picture.
   * If it shouldn't be changed, use [do-not-modify] instead.
   */
  pictureUrl: string;
}

/** MsgUpdateOperatorResponse is the return value of MsgUpdateOperator. */
export interface MsgUpdateOperatorResponse {
}

/**
 * MsgDeactivateOperator defines the message structure for the
 * DeactivateOperator gRPC service method. It allows the operator owner to
 * signal that the operator will become inactive. This should be used to signal
 * users that the operator is going to stop performing services and they should
 * switch to another operator.
 */
export interface MsgDeactivateOperator {
  /** Sender is the address of the user deactivating the operator */
  sender: string;
  /** OperatorID represents the ID of the operator to be deregistered */
  operatorId: number;
}

/** MsgDeactivateOperatorResponse is the return value of MsgDeactivateOperator. */
export interface MsgDeactivateOperatorResponse {
}

/**
 * MsgReactivateOperator defines the message structure for the
 * ReactivateOperator gRPC service method. It allows the operator owner to
 * reactivate an inactive operator.
 */
export interface MsgReactivateOperator {
  /** Sender is the address of the user reactivating the operator */
  sender: string;
  /** OperatorID represents the ID of the operator to be reactivated */
  operatorId: number;
}

/** MsgReactivateOperatorResponse is the return value of MsgReactivateOperator. */
export interface MsgReactivateOperatorResponse {
}

/**
 * MsgDeleteOperator defines the message structure for the
 * DeleteOperator gRPC service method. It allows the operator owner to
 * delete a deactivated operator.
 */
export interface MsgDeleteOperator {
  /** Sender is the address of the user deleting the operator */
  sender: string;
  /** OperatorID represents the ID of the operator to be deleted */
  operatorId: number;
}

/** MsgDeleteOperatorResponse is the return value of MsgDeleteOperator. */
export interface MsgDeleteOperatorResponse {
}

/**
 * MsgSetOperatorParams defines the message structure for the
 * SetOperatorParams gRPC service method. It allows the operator admin to
 * update the operator's parameters.
 */
export interface MsgSetOperatorParams {
  sender: string;
  operatorId: number;
  params: OperatorParams | undefined;
}

/**
 * MsgSetOperatorParamsResponse is the return value of
 * MsgSetOperatorParams.
 */
export interface MsgSetOperatorParamsResponse {
}

/**
 * MsgTransferOperatorOwnership defines the message structure for the
 * TransferOperatorOwnership gRPC service method. It allows an operator admin to
 * transfer the ownership of the operator to another account.
 */
export interface MsgTransferOperatorOwnership {
  /** Sender is the address of the user transferring the ownership */
  sender: string;
  /** OperatorID represents the ID of the operator to transfer ownership */
  operatorId: number;
  /** NewAdmin is the address of the new admin of the operator */
  newAdmin: string;
}

/**
 * MsgTransferOperatorOwnershipResponse is the return value of
 * MsgTransferOperatorOwnership.
 */
export interface MsgTransferOperatorOwnershipResponse {
}

/**
 * MsgUpdateParams defines the message structure for the UpdateParams gRPC
 * service method. It allows the authority to update the module parameters.
 */
export interface MsgUpdateParams {
  /**
   * Authority is the address that controls the module (defaults to x/gov unless
   * overwritten).
   */
  authority: string;
  /**
   * Params define the parameters to update.
   *
   * NOTE: All parameters must be supplied.
   */
  params: Params | undefined;
}

/** MsgUpdateParamsResponse is the return value of MsgUpdateParams. */
export interface MsgUpdateParamsResponse {
}

function createBaseMsgRegisterOperator(): MsgRegisterOperator {
  return { sender: "", moniker: "", website: "", pictureUrl: "", feeAmount: [] };
}

export const MsgRegisterOperator: MessageFns<MsgRegisterOperator> = {
  encode(message: MsgRegisterOperator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.moniker !== "") {
      writer.uint32(18).string(message.moniker);
    }
    if (message.website !== "") {
      writer.uint32(26).string(message.website);
    }
    if (message.pictureUrl !== "") {
      writer.uint32(34).string(message.pictureUrl);
    }
    for (const v of message.feeAmount) {
      Coin.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterOperator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moniker = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pictureUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.feeAmount.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterOperator {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      moniker: isSet(object.moniker) ? gt.String(object.moniker) : "",
      website: isSet(object.website) ? gt.String(object.website) : "",
      pictureUrl: isSet(object.pictureUrl) ? gt.String(object.pictureUrl) : "",
      feeAmount: gt.Array.isArray(object?.feeAmount) ? object.feeAmount.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgRegisterOperator): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.moniker !== "") {
      obj.moniker = message.moniker;
    }
    if (message.website !== "") {
      obj.website = message.website;
    }
    if (message.pictureUrl !== "") {
      obj.pictureUrl = message.pictureUrl;
    }
    if (message.feeAmount?.length) {
      obj.feeAmount = message.feeAmount.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRegisterOperator>): MsgRegisterOperator {
    return MsgRegisterOperator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRegisterOperator>): MsgRegisterOperator {
    const message = createBaseMsgRegisterOperator();
    message.sender = object.sender ?? "";
    message.moniker = object.moniker ?? "";
    message.website = object.website ?? "";
    message.pictureUrl = object.pictureUrl ?? "";
    message.feeAmount = object.feeAmount?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgRegisterOperatorResponse(): MsgRegisterOperatorResponse {
  return { newOperatorId: 0 };
}

export const MsgRegisterOperatorResponse: MessageFns<MsgRegisterOperatorResponse> = {
  encode(message: MsgRegisterOperatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newOperatorId !== 0) {
      writer.uint32(8).uint32(message.newOperatorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterOperatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterOperatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.newOperatorId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterOperatorResponse {
    return { newOperatorId: isSet(object.newOperatorId) ? gt.Number(object.newOperatorId) : 0 };
  },

  toJSON(message: MsgRegisterOperatorResponse): unknown {
    const obj: any = {};
    if (message.newOperatorId !== 0) {
      obj.newOperatorId = Math.round(message.newOperatorId);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRegisterOperatorResponse>): MsgRegisterOperatorResponse {
    return MsgRegisterOperatorResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRegisterOperatorResponse>): MsgRegisterOperatorResponse {
    const message = createBaseMsgRegisterOperatorResponse();
    message.newOperatorId = object.newOperatorId ?? 0;
    return message;
  },
};

function createBaseMsgUpdateOperator(): MsgUpdateOperator {
  return { sender: "", operatorId: 0, moniker: "", website: "", pictureUrl: "" };
}

export const MsgUpdateOperator: MessageFns<MsgUpdateOperator> = {
  encode(message: MsgUpdateOperator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.operatorId !== 0) {
      writer.uint32(16).uint32(message.operatorId);
    }
    if (message.moniker !== "") {
      writer.uint32(26).string(message.moniker);
    }
    if (message.website !== "") {
      writer.uint32(34).string(message.website);
    }
    if (message.pictureUrl !== "") {
      writer.uint32(42).string(message.pictureUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateOperator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operatorId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.moniker = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pictureUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateOperator {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      operatorId: isSet(object.operatorId) ? gt.Number(object.operatorId) : 0,
      moniker: isSet(object.moniker) ? gt.String(object.moniker) : "",
      website: isSet(object.website) ? gt.String(object.website) : "",
      pictureUrl: isSet(object.pictureUrl) ? gt.String(object.pictureUrl) : "",
    };
  },

  toJSON(message: MsgUpdateOperator): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.operatorId !== 0) {
      obj.operatorId = Math.round(message.operatorId);
    }
    if (message.moniker !== "") {
      obj.moniker = message.moniker;
    }
    if (message.website !== "") {
      obj.website = message.website;
    }
    if (message.pictureUrl !== "") {
      obj.pictureUrl = message.pictureUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateOperator>): MsgUpdateOperator {
    return MsgUpdateOperator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateOperator>): MsgUpdateOperator {
    const message = createBaseMsgUpdateOperator();
    message.sender = object.sender ?? "";
    message.operatorId = object.operatorId ?? 0;
    message.moniker = object.moniker ?? "";
    message.website = object.website ?? "";
    message.pictureUrl = object.pictureUrl ?? "";
    return message;
  },
};

function createBaseMsgUpdateOperatorResponse(): MsgUpdateOperatorResponse {
  return {};
}

export const MsgUpdateOperatorResponse: MessageFns<MsgUpdateOperatorResponse> = {
  encode(_: MsgUpdateOperatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateOperatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateOperatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateOperatorResponse {
    return {};
  },

  toJSON(_: MsgUpdateOperatorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateOperatorResponse>): MsgUpdateOperatorResponse {
    return MsgUpdateOperatorResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateOperatorResponse>): MsgUpdateOperatorResponse {
    const message = createBaseMsgUpdateOperatorResponse();
    return message;
  },
};

function createBaseMsgDeactivateOperator(): MsgDeactivateOperator {
  return { sender: "", operatorId: 0 };
}

export const MsgDeactivateOperator: MessageFns<MsgDeactivateOperator> = {
  encode(message: MsgDeactivateOperator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.operatorId !== 0) {
      writer.uint32(16).uint32(message.operatorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeactivateOperator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeactivateOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operatorId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeactivateOperator {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      operatorId: isSet(object.operatorId) ? gt.Number(object.operatorId) : 0,
    };
  },

  toJSON(message: MsgDeactivateOperator): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.operatorId !== 0) {
      obj.operatorId = Math.round(message.operatorId);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgDeactivateOperator>): MsgDeactivateOperator {
    return MsgDeactivateOperator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgDeactivateOperator>): MsgDeactivateOperator {
    const message = createBaseMsgDeactivateOperator();
    message.sender = object.sender ?? "";
    message.operatorId = object.operatorId ?? 0;
    return message;
  },
};

function createBaseMsgDeactivateOperatorResponse(): MsgDeactivateOperatorResponse {
  return {};
}

export const MsgDeactivateOperatorResponse: MessageFns<MsgDeactivateOperatorResponse> = {
  encode(_: MsgDeactivateOperatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeactivateOperatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeactivateOperatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeactivateOperatorResponse {
    return {};
  },

  toJSON(_: MsgDeactivateOperatorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgDeactivateOperatorResponse>): MsgDeactivateOperatorResponse {
    return MsgDeactivateOperatorResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgDeactivateOperatorResponse>): MsgDeactivateOperatorResponse {
    const message = createBaseMsgDeactivateOperatorResponse();
    return message;
  },
};

function createBaseMsgReactivateOperator(): MsgReactivateOperator {
  return { sender: "", operatorId: 0 };
}

export const MsgReactivateOperator: MessageFns<MsgReactivateOperator> = {
  encode(message: MsgReactivateOperator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.operatorId !== 0) {
      writer.uint32(16).uint32(message.operatorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgReactivateOperator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReactivateOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operatorId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgReactivateOperator {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      operatorId: isSet(object.operatorId) ? gt.Number(object.operatorId) : 0,
    };
  },

  toJSON(message: MsgReactivateOperator): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.operatorId !== 0) {
      obj.operatorId = Math.round(message.operatorId);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgReactivateOperator>): MsgReactivateOperator {
    return MsgReactivateOperator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgReactivateOperator>): MsgReactivateOperator {
    const message = createBaseMsgReactivateOperator();
    message.sender = object.sender ?? "";
    message.operatorId = object.operatorId ?? 0;
    return message;
  },
};

function createBaseMsgReactivateOperatorResponse(): MsgReactivateOperatorResponse {
  return {};
}

export const MsgReactivateOperatorResponse: MessageFns<MsgReactivateOperatorResponse> = {
  encode(_: MsgReactivateOperatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgReactivateOperatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReactivateOperatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgReactivateOperatorResponse {
    return {};
  },

  toJSON(_: MsgReactivateOperatorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgReactivateOperatorResponse>): MsgReactivateOperatorResponse {
    return MsgReactivateOperatorResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgReactivateOperatorResponse>): MsgReactivateOperatorResponse {
    const message = createBaseMsgReactivateOperatorResponse();
    return message;
  },
};

function createBaseMsgDeleteOperator(): MsgDeleteOperator {
  return { sender: "", operatorId: 0 };
}

export const MsgDeleteOperator: MessageFns<MsgDeleteOperator> = {
  encode(message: MsgDeleteOperator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.operatorId !== 0) {
      writer.uint32(16).uint32(message.operatorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteOperator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operatorId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteOperator {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      operatorId: isSet(object.operatorId) ? gt.Number(object.operatorId) : 0,
    };
  },

  toJSON(message: MsgDeleteOperator): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.operatorId !== 0) {
      obj.operatorId = Math.round(message.operatorId);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgDeleteOperator>): MsgDeleteOperator {
    return MsgDeleteOperator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgDeleteOperator>): MsgDeleteOperator {
    const message = createBaseMsgDeleteOperator();
    message.sender = object.sender ?? "";
    message.operatorId = object.operatorId ?? 0;
    return message;
  },
};

function createBaseMsgDeleteOperatorResponse(): MsgDeleteOperatorResponse {
  return {};
}

export const MsgDeleteOperatorResponse: MessageFns<MsgDeleteOperatorResponse> = {
  encode(_: MsgDeleteOperatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteOperatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteOperatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteOperatorResponse {
    return {};
  },

  toJSON(_: MsgDeleteOperatorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgDeleteOperatorResponse>): MsgDeleteOperatorResponse {
    return MsgDeleteOperatorResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgDeleteOperatorResponse>): MsgDeleteOperatorResponse {
    const message = createBaseMsgDeleteOperatorResponse();
    return message;
  },
};

function createBaseMsgSetOperatorParams(): MsgSetOperatorParams {
  return { sender: "", operatorId: 0, params: undefined };
}

export const MsgSetOperatorParams: MessageFns<MsgSetOperatorParams> = {
  encode(message: MsgSetOperatorParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.operatorId !== 0) {
      writer.uint32(16).uint32(message.operatorId);
    }
    if (message.params !== undefined) {
      OperatorParams.encode(message.params, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetOperatorParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetOperatorParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operatorId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.params = OperatorParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetOperatorParams {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      operatorId: isSet(object.operatorId) ? gt.Number(object.operatorId) : 0,
      params: isSet(object.params) ? OperatorParams.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgSetOperatorParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.operatorId !== 0) {
      obj.operatorId = Math.round(message.operatorId);
    }
    if (message.params !== undefined) {
      obj.params = OperatorParams.toJSON(message.params);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSetOperatorParams>): MsgSetOperatorParams {
    return MsgSetOperatorParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSetOperatorParams>): MsgSetOperatorParams {
    const message = createBaseMsgSetOperatorParams();
    message.sender = object.sender ?? "";
    message.operatorId = object.operatorId ?? 0;
    message.params = (object.params !== undefined && object.params !== null)
      ? OperatorParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgSetOperatorParamsResponse(): MsgSetOperatorParamsResponse {
  return {};
}

export const MsgSetOperatorParamsResponse: MessageFns<MsgSetOperatorParamsResponse> = {
  encode(_: MsgSetOperatorParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetOperatorParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetOperatorParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetOperatorParamsResponse {
    return {};
  },

  toJSON(_: MsgSetOperatorParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSetOperatorParamsResponse>): MsgSetOperatorParamsResponse {
    return MsgSetOperatorParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSetOperatorParamsResponse>): MsgSetOperatorParamsResponse {
    const message = createBaseMsgSetOperatorParamsResponse();
    return message;
  },
};

function createBaseMsgTransferOperatorOwnership(): MsgTransferOperatorOwnership {
  return { sender: "", operatorId: 0, newAdmin: "" };
}

export const MsgTransferOperatorOwnership: MessageFns<MsgTransferOperatorOwnership> = {
  encode(message: MsgTransferOperatorOwnership, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.operatorId !== 0) {
      writer.uint32(16).uint32(message.operatorId);
    }
    if (message.newAdmin !== "") {
      writer.uint32(26).string(message.newAdmin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransferOperatorOwnership {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferOperatorOwnership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operatorId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newAdmin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTransferOperatorOwnership {
    return {
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      operatorId: isSet(object.operatorId) ? gt.Number(object.operatorId) : 0,
      newAdmin: isSet(object.newAdmin) ? gt.String(object.newAdmin) : "",
    };
  },

  toJSON(message: MsgTransferOperatorOwnership): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.operatorId !== 0) {
      obj.operatorId = Math.round(message.operatorId);
    }
    if (message.newAdmin !== "") {
      obj.newAdmin = message.newAdmin;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgTransferOperatorOwnership>): MsgTransferOperatorOwnership {
    return MsgTransferOperatorOwnership.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgTransferOperatorOwnership>): MsgTransferOperatorOwnership {
    const message = createBaseMsgTransferOperatorOwnership();
    message.sender = object.sender ?? "";
    message.operatorId = object.operatorId ?? 0;
    message.newAdmin = object.newAdmin ?? "";
    return message;
  },
};

function createBaseMsgTransferOperatorOwnershipResponse(): MsgTransferOperatorOwnershipResponse {
  return {};
}

export const MsgTransferOperatorOwnershipResponse: MessageFns<MsgTransferOperatorOwnershipResponse> = {
  encode(_: MsgTransferOperatorOwnershipResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransferOperatorOwnershipResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferOperatorOwnershipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTransferOperatorOwnershipResponse {
    return {};
  },

  toJSON(_: MsgTransferOperatorOwnershipResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTransferOperatorOwnershipResponse>): MsgTransferOperatorOwnershipResponse {
    return MsgTransferOperatorOwnershipResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgTransferOperatorOwnershipResponse>): MsgTransferOperatorOwnershipResponse {
    const message = createBaseMsgTransferOperatorOwnershipResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? gt.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

/** Msg defines the avs module's gRPC message service. */
export interface Msg {
  /** RegisterOperator defines the operation for registering a new operator. */
  RegisterOperator(request: MsgRegisterOperator): Promise<MsgRegisterOperatorResponse>;
  /**
   * UpdateOperator defines the operation for updating an operator's details.
   * The operator owner can update the moniker, website, and picture URL.
   */
  UpdateOperator(request: MsgUpdateOperator): Promise<MsgUpdateOperatorResponse>;
  /**
   * DeactivateOperator defines the operation for deactivating an
   * operator. Operators will require some time in order to be deactivated.
   * This time is defined by the governance parameters.
   */
  DeactivateOperator(request: MsgDeactivateOperator): Promise<MsgDeactivateOperatorResponse>;
  /**
   * ReactivateOperator defines the operation for reactivating an
   * inactive operator.
   */
  ReactivateOperator(request: MsgReactivateOperator): Promise<MsgReactivateOperatorResponse>;
  /** DeleteOperator defines the operation for deleting a deactivated operator. */
  DeleteOperator(request: MsgDeleteOperator): Promise<MsgDeleteOperatorResponse>;
  /**
   * TransferOperatorOwnership defines the operation for transferring the
   * ownership of an operator to another account.
   */
  TransferOperatorOwnership(request: MsgTransferOperatorOwnership): Promise<MsgTransferOperatorOwnershipResponse>;
  /**
   * SetOperatorParams defines the operation for setting a operator's
   * parameters.
   */
  SetOperatorParams(request: MsgSetOperatorParams): Promise<MsgSetOperatorParamsResponse>;
  /**
   * UpdateParams defines a governance operation for updating the module
   * parameters.
   * The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}

export const MsgServiceName = "milkyway.operators.v1.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.RegisterOperator = this.RegisterOperator.bind(this);
    this.UpdateOperator = this.UpdateOperator.bind(this);
    this.DeactivateOperator = this.DeactivateOperator.bind(this);
    this.ReactivateOperator = this.ReactivateOperator.bind(this);
    this.DeleteOperator = this.DeleteOperator.bind(this);
    this.TransferOperatorOwnership = this.TransferOperatorOwnership.bind(this);
    this.SetOperatorParams = this.SetOperatorParams.bind(this);
    this.UpdateParams = this.UpdateParams.bind(this);
  }
  RegisterOperator(request: MsgRegisterOperator): Promise<MsgRegisterOperatorResponse> {
    const data = MsgRegisterOperator.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterOperator", data);
    return promise.then((data) => MsgRegisterOperatorResponse.decode(new BinaryReader(data)));
  }

  UpdateOperator(request: MsgUpdateOperator): Promise<MsgUpdateOperatorResponse> {
    const data = MsgUpdateOperator.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateOperator", data);
    return promise.then((data) => MsgUpdateOperatorResponse.decode(new BinaryReader(data)));
  }

  DeactivateOperator(request: MsgDeactivateOperator): Promise<MsgDeactivateOperatorResponse> {
    const data = MsgDeactivateOperator.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeactivateOperator", data);
    return promise.then((data) => MsgDeactivateOperatorResponse.decode(new BinaryReader(data)));
  }

  ReactivateOperator(request: MsgReactivateOperator): Promise<MsgReactivateOperatorResponse> {
    const data = MsgReactivateOperator.encode(request).finish();
    const promise = this.rpc.request(this.service, "ReactivateOperator", data);
    return promise.then((data) => MsgReactivateOperatorResponse.decode(new BinaryReader(data)));
  }

  DeleteOperator(request: MsgDeleteOperator): Promise<MsgDeleteOperatorResponse> {
    const data = MsgDeleteOperator.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteOperator", data);
    return promise.then((data) => MsgDeleteOperatorResponse.decode(new BinaryReader(data)));
  }

  TransferOperatorOwnership(request: MsgTransferOperatorOwnership): Promise<MsgTransferOperatorOwnershipResponse> {
    const data = MsgTransferOperatorOwnership.encode(request).finish();
    const promise = this.rpc.request(this.service, "TransferOperatorOwnership", data);
    return promise.then((data) => MsgTransferOperatorOwnershipResponse.decode(new BinaryReader(data)));
  }

  SetOperatorParams(request: MsgSetOperatorParams): Promise<MsgSetOperatorParamsResponse> {
    const data = MsgSetOperatorParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetOperatorParams", data);
    return promise.then((data) => MsgSetOperatorParamsResponse.decode(new BinaryReader(data)));
  }

  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
